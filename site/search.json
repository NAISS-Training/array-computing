{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Array Computing with Eigen","text":"<p>This is a course on array computing with the C++ library Eigen. The course is intended for students with a basic knowledge of C++ programming and linear algebra.</p> <p>Jonas Lindemann, 2025</p>","path":["Array Computing with Eigen"],"tags":[]},{"location":"#contents","level":2,"title":"Contents","text":"<ul> <li>Setup</li> <li>Schedule</li> <li>Links</li> <li>Exercises</li> <li>Solutions</li> </ul>","path":["Array Computing with Eigen"],"tags":[]},{"location":"exercises/","level":1,"title":"Exercises","text":"<p>Use the button below to open a template in Compiler Explorer with the Eigen library included. You can use this template to complete the exercises below.</p> <ul> <li>Open solution in Compiler Explorer</li> </ul>","path":["Exercises"],"tags":[]},{"location":"exercises/#basic-matrix-and-vector-operations","level":2,"title":"Basic Matrix and Vector Operations","text":"","path":["Exercises"],"tags":[]},{"location":"exercises/#1-vector-creation-and-access","level":3,"title":"1. Vector Creation and Access","text":"<ul> <li>Create a 5-element vector using Eigen and initialize it with values 1 through 5.</li> <li>Print the vector's elements and demonstrate how to access individual elements.</li> </ul>","path":["Exercises"],"tags":[]},{"location":"exercises/#2-matrix-initialization","level":3,"title":"2. Matrix Initialization","text":"<ul> <li>Create a 3x3 matrix with all elements set to zero.</li> <li>Initialize a 2x4 matrix with specific values of your choice.</li> <li>Print both matrices to verify their contents.</li> </ul>","path":["Exercises"],"tags":[]},{"location":"exercises/#3-basic-math-functions","level":3,"title":"3. Basic Math Functions","text":"<ul> <li>Create a vector with values ranging from -5 to 5.</li> <li>Apply the absolute value, square root (for positive elements), and exponential functions.</li> <li>Calculate the sum, mean, minimum, and maximum values of the vector.</li> </ul> <p>Tip</p> <p>If you want to apply sqrt to all components in a vector you have to use the <code>.cwiseSqrt()</code> method. The same applies to other functions like <code>.cwiseAbs()</code> and <code>.cwiseExp()</code>. If you want to apply a function to all values in a matrix, you can use the <code>.array()</code> method to convert the matrix to an array and then apply the function. <code>A.array().sqrt()</code> will apply the square root to all elements in the matrix.</p> <p>It is also possible to use the <code>.unaryExpr()</code> method to apply a function to all elements in a matrix. For example, <code>A.unaryExpr([](double x) { return foo(x); });</code> will apply the function <code>foo()</code> to all elements in the matrix <code>A</code>.</p>","path":["Exercises"],"tags":[]},{"location":"exercises/#4-coefficient-wise-operations","level":3,"title":"4. Coefficient-wise Operations","text":"<ul> <li>Create two vectors of the same length.</li> <li>Perform element-wise multiplication, division, and power operations.</li> <li>Calculate the dot product and compare with element-wise multiplication.</li> </ul>","path":["Exercises"],"tags":[]},{"location":"exercises/#5-matrix-operations","level":3,"title":"5. Matrix Operations","text":"<ul> <li>Create two 3x3 matrices with different values.</li> <li>Perform and print the results of addition, subtraction, and element-wise multiplication.</li> <li>Calculate and print the matrix product of the two matrices.</li> </ul>","path":["Exercises"],"tags":[]},{"location":"exercises/#6-vector-matrix-operations","level":3,"title":"6. Vector-Matrix Operations","text":"<ul> <li>Create a 3x3 matrix and a 3-element vector.</li> <li>Multiply the matrix by the vector and explain the result.</li> <li>Experiment with different ways to perform the multiplication.</li> </ul>","path":["Exercises"],"tags":[]},{"location":"exercises/#7-special-matrix-operations","level":3,"title":"7. Special Matrix Operations","text":"<ul> <li>Create a 4x4 matrix and calculate its determinant, inverse, and transpose.</li> <li>Verify that <code>A * A^-1</code> equals the identity matrix (within numerical precision).</li> <li>Explore how to check if a matrix is singular and handle potential errors.</li> </ul> <p>Tip</p> <p>In addition to using the <code>.determinant()</code> to determine if a matrix is singular it is also possible to use the <code>.fullPivLu().isInvertible()</code> method. This method returns a boolean value indicating if the matrix is invertible. The <code>.fullPivLu()</code> method can also be used to calculate the inverse of a matrix.</p>","path":["Exercises"],"tags":[]},{"location":"exercises/#advanced-matrix-operations","level":2,"title":"Advanced Matrix Operations","text":"","path":["Exercises"],"tags":[]},{"location":"exercises/#8-block-operations","level":3,"title":"8. Block Operations","text":"<ul> <li>Create a 4x4 matrix with sequential numbers (1-16).</li> <li>Extract the 2x2 block in the top-left corner.</li> <li>Extract the 2x2 block in the bottom-right corner.</li> <li>Replace the bottom-left 2x2 block with a new 2x2 matrix.</li> </ul> <p>Tip</p> <p>The <code>.block()</code> method can be used to extract a block from a matrix. The method takes four arguments: the row and column index of the top-left corner of the block, and the number of rows and columns in the block. For example, <code>A.block(0, 0, 2, 2)</code> will extract a 2x2 block from the top-left corner of the matrix <code>A</code>. It is also possible to assign a matrix using the <code>.block()</code> method. <code>A.block(0, 0, 2, 2) = B;</code> will replace the top-left 2x2 block in <code>A</code> with the matrix <code>B</code>.</p>","path":["Exercises"],"tags":[]},{"location":"exercises/#9-row-and-column-operations","level":3,"title":"9. Row and Column Operations","text":"<ul> <li>Create a 3x4 matrix with random values.</li> <li>Extract the second row and third column.</li> <li>Replace the first row with new values.</li> <li>Swap two columns of your choice.</li> </ul> <p>Tip</p> <p>The <code>.swap()</code> method can be used to swap two columns in a matrix.</p>","path":["Exercises"],"tags":[]},{"location":"exercises/#10-resizing-and-reshaping","level":3,"title":"10. Resizing and Reshaping","text":"<ul> <li>Create a 2x3 matrix and then resize it to a 3x2 matrix.</li> <li>Create a 6-element vector and reshape it into a 2x3 matrix.</li> <li>Discuss what happens to the elements during these operations.</li> </ul> <p>Tip</p> <p>Use the <code>.reshaped()</code> method to reshape a matrix.</p>","path":["Exercises"],"tags":[]},{"location":"exercises/#11-concatenation","level":3,"title":"11. Concatenation","text":"<ul> <li>Create two 2x2 matrices.</li> <li>Horizontally concatenate them to form a 2x4 matrix.</li> <li>Vertically concatenate them to form a 4x2 matrix.</li> <li>Create and demonstrate a function that can concatenate matrices of compatible dimensions.</li> </ul> <p>Tip</p> <p>The <code>&lt;&lt;</code> operator can be used to concatenate matrices. <code>A &lt;&lt; B, C;</code> will concatenate the matrices <code>B</code> and <code>C</code> horizontally or vertically depending on the matrix shapes.</p>","path":["Exercises"],"tags":[]},{"location":"exercises/#12-advanced-slicing","level":3,"title":"12. Advanced Slicing","text":"<ul> <li>Create a 5x5 matrix with sequential values.</li> <li>Extract non-contiguous rows and columns (for example rows 1, 3, 4 and columns 0, 2).</li> <li>Extract a diagonal or anti-diagonal of the matrix.</li> <li>Create a tiled pattern by repeating a smaller matrix.</li> </ul> <p>Tip</p> <p><code>std::vector&lt;int&gt; indices = {1, 3, 4};</code> can be used as indices to extract non-contiguous areas of a matrix.</p>","path":["Exercises"],"tags":[]},{"location":"exercises/#13-linear-algebra-operations","level":3,"title":"13. Linear Algebra Operations","text":"<ul> <li>Create a system of linear equations represented as <code>Ax = b</code>.</li> <li>Solve the system using Eigen's solver capabilities.</li> <li>Verify your solution by substituting it back into the original equations.</li> </ul> <p>Tip</p> <p>Use <code>.fullPivLu()</code> to solve a system of linear equations.</p>","path":["Exercises"],"tags":[]},{"location":"exercises/#14-eigenvalues-and-eigenvectors","level":3,"title":"14. Eigenvalues and Eigenvectors","text":"<ul> <li>Create a symmetric 3x3 matrix.</li> <li>Calculate its eigenvalues and eigenvectors.</li> <li>Verify that <code>A v = lambda v</code> for each eigenvalue-eigenvector pair.</li> </ul> <p>Tip</p> <p>Use the class <code>SelfAdjointEigenSolver&lt;Eigen::Matrix3d&gt; es(A);</code> to compute eigenvalues and eigenvectors. Use the <code>es.eigenvalues()</code> and <code>es.eigenvectors()</code> methods to calculate the eigenvalues and eigenvectors of a matrix.</p>","path":["Exercises"],"tags":[]},{"location":"exercises/#practical-applications","level":2,"title":"Practical Applications","text":"","path":["Exercises"],"tags":[]},{"location":"exercises/#15-image-processing-basics","level":3,"title":"15. Image Processing Basics","text":"<ul> <li>Represent a grayscale image as an Eigen matrix.</li> <li>Implement basic operations like brightness adjustment and contrast enhancement.</li> <li>Apply simple filters (for example blur) using matrix operations.</li> </ul> <p>Tip</p> <p>Use the Img library to load images that can be converted to Eigen matrices. The library can be found here:</p> <ul> <li>img: single-header-only C++ image library with Eigen interoperability</li> </ul> <p>An image can be loaded and converted to a grayscale image (range [0.0..1.0]) using the following code snippet:</p> <pre><code>Img::ImageGd image;\n\nstd::cout &lt;&lt; \"Loading image...\" &lt;&lt; std::endl;\n\nif (!Img::load(\"images/half-moon-986269.png\", image))\n{\n    std::cout &lt;&lt; \"Error loading image\" &lt;&lt; std::endl;\n    return 1;\n}\n</code></pre> <p>Conversion from an Image class to an Eigen matrix can be done using the <code>.as_matrix()</code> method.</p> <pre><code>MatrixXd matrix = image.as_matrix();\n</code></pre> <p>Converting back to an Image class can be done using the following function:</p> <pre><code>Img::ImageGd copyToImage(const Eigen::MatrixXd &amp;mat)\n{\n    ImageGd image;\n    image.resize(mat.rows(), mat.cols());\n    for (int i = 0; i &lt; mat.rows(); i++)\n        for (int j = 0; j &lt; mat.cols(); j++)\n            image(i, j) = mat(i, j);\n\n    return image;\n}\n</code></pre> <p>Saving the image to a file can be done using the following code snippet:</p> <pre><code>if (!Img::save(\"output.png\", copyToImage(matrix)))\n{\n    std::cout &lt;&lt; \"Error saving image\" &lt;&lt; std::endl;\n    return 1;\n}\n</code></pre> <p>The gaussian kernel can be generated using the following function:</p> <pre><code>Eigen::MatrixXd createGaussianKernel(int size, double sigma)\n{\n    if (size % 2 == 0)\n    {\n        size++; // Make sure kernel size is odd\n    }\n\n    Eigen::MatrixXd kernel(size, size);\n    int center = size / 2;\n    double sum = 0.0;\n\n    // Fill the kernel with Gaussian values\n    for (int y = 0; y &lt; size; y++)\n    {\n        for (int x = 0; x &lt; size; x++)\n        {\n            int dx = x - center;\n            int dy = y - center;\n            float exponent = -(dx * dx + dy * dy) / (2 * sigma * sigma);\n            kernel(y, x) = std::exp(exponent) / (2 * std::numbers::pi * sigma * sigma);\n            sum += kernel(y, x);\n        }\n    }\n\n    // Normalize the kernel so its sum equals 1\n    kernel /= sum;\n\n    return kernel;\n}\n</code></pre>","path":["Exercises"],"tags":[]},{"location":"links/","level":1,"title":"Links","text":"<ul> <li>Slides</li> <li>Official Eigen home page</li> <li>Eigen documentation</li> <li>The Engineer's Guide to C++</li> <li>C++ Reference documentation</li> <li>The C++ Standard</li> <li>CMake</li> <li>CMake documentation</li> <li>C/C++ dependency manager from Microsoft</li> <li>LUNARC Documentation</li> </ul>","path":["Links"],"tags":[]},{"location":"schedule/","level":1,"title":"Schedule","text":"Time Description Type 9.00 - 9.05 Introduction Lecture 9.05 - 9.15 Setting up development environment Lab/Interactive 9.15 - 10.00 Working with matrices and vectors Lecture 10.00 - 10.20 Coffee break 10.20 - 11.00 Working with exercises Lab 11.00 - 12.00 Advanced matrix operations Lecture 12.00 - 13.00 Lunch 13.00 - 13.40 Working with exercises Lab 13.40 - 14.00 Best practice and integration Lecture 14.00 - 14.30 Working with exercises Lab 14.30 - 14.45 Coffee break Lecture 14.45 - 15.15 Using Eigen in parallel applications Lecture","path":["Schedule"],"tags":[]},{"location":"setup/","level":1,"title":"Setup","text":"<p>This document describes how to set up a development environment for the course.</p>","path":["Setup"],"tags":[]},{"location":"setup/#using-cosmos-at-lunarc","level":2,"title":"Using COSMOS at LUNARC","text":"<p>If you have applied for an account at LUNARC you can login to the remote desktop environment or connect using a SSH terminal. More information can be found here:</p> <ul> <li>Login into remote desktop environment</li> <li>Login using SSH</li> </ul> <p>A suitable environment can be loaded using the following commands:</p> <pre><code>module load foss/2024a\nmodule load Eigen\nmodule load CMake\n</code></pre> <p>To validate the environment you can run the following commands:</p> <pre><code>g++ --version\ncmake --version\n</code></pre> <p>This should give output similar to:</p> <pre><code>$ g++ --version\ng++ (GCC) 13.3.0\nCopyright (C) 2023 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n$ cmake --version\ncmake version 3.29.3\n\nCMake suite maintained and supported by Kitware (kitware.com/cmake).\n</code></pre> <p>To validate that Eigen is working properly, create a file called <code>ex0.cpp</code> with the following content:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;Eigen/Dense&gt;\n\nint main()\n{\n    Eigen::Matrix3d m = Eigen::Matrix3d::Random();\n    std::cout &lt;&lt; \"Here is the matrix m:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; m &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Compile the file using the following command:</p> <pre><code>g++ ex0.cpp -o ex0\n</code></pre> <p>Run the compiled file using the following command:</p> <pre><code>./ex0\n</code></pre> <p>This should give output similar to:</p> <pre><code>Here is the matrix m:\n0.680375   0.59688 -0.329554\n-0.211234  0.823295  0.536459\n0.566198 -0.604897 -0.444451\n</code></pre>","path":["Setup"],"tags":[]},{"location":"setup/#linux","level":2,"title":"Linux","text":"<p>The easiest way to set up a development environment on Linux is to use a package manager. The following commands can be used to install the necessary tools on Ubuntu:</p> <pre><code>sudo apt-get update\nsudo apt-get install g++\nsudo apt-get install cmake\nsudo apt-get install libeigen3-dev\n</code></pre> <p>To validate the environment you can run the following commands:</p> <pre><code>g++ --version\ncmake --version\n</code></pre> <p>This should give output similar to:</p> <pre><code>g++ (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0\nCopyright (C) 2023 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\ncmake version 3.28.3\n\nCMake suite maintained and supported by Kitware (kitware.com/cmake).\n</code></pre> <p>To validate that Eigen is working properly, create a file called <code>ex0.cpp</code> with the following content:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;Eigen/Dense&gt;\n\nint main()\n{\n    Eigen::Matrix3d m = Eigen::Matrix3d::Random();\n    std::cout &lt;&lt; \"Here is the matrix m:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; m &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Compile the file using the following command:</p> <pre><code>g++ ex0.cpp -I/usr/include/eigen3 -o ex0\n</code></pre> <p>Run the compiled file using the following command:</p> <pre><code>./ex0\n</code></pre> <p>This should give output similar to:</p> <pre><code>Here is the matrix m:\n0.680375   0.59688 -0.329554\n-0.211234  0.823295  0.536459\n0.566198 -0.604897 -0.444451\n</code></pre>","path":["Setup"],"tags":[]},{"location":"setup/#macos","level":2,"title":"macOS","text":"<p>The easiest way to set up a development environment on macOS is to use a package manager. The following commands can be used to install the necessary tools using Homebrew:</p> <pre><code>brew install gcc\nbrew install cmake\nbrew install eigen\n</code></pre> <p>To validate that Eigen is working properly, create a file called <code>ex0.cpp</code> with the following content:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;Eigen/Dense&gt;\n\nint main()\n{\n    Eigen::Matrix3d m = Eigen::Matrix3d::Random();\n    std::cout &lt;&lt; \"Here is the matrix m:\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; m &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Compile the file using the following command:</p> <pre><code>g++ -std=c++11 -I/usr/local/include/eigen3 ex0.cpp -o ex0\n</code></pre> <p>Run the compiled file using the following command:</p> <pre><code>./ex0\n</code></pre> <p>This should give output similar to:</p> <pre><code>Here is the matrix m:\n0.680375   0.59688 -0.329554\n-0.211234  0.823295  0.536459\n0.566198 -0.604897 -0.444451\n</code></pre>","path":["Setup"],"tags":[]},{"location":"setup/#windows","level":2,"title":"Windows","text":"<p>On Windows you have two options. The first one is to install the Microsoft Visual Studio IDE and use the Visual Studio Command Prompt. The second option is to use the Windows Subsystem for Linux (WSL). The easiest is probably to install WSL and use the Ubuntu distribution. Then the compilers and libraries are installed in the same way as described for Linux.</p>","path":["Setup"],"tags":[]},{"location":"solutions/","level":1,"title":"Solutions","text":"","path":["Solutions"],"tags":[]},{"location":"solutions/#basic-matrix-and-vector-operations","level":2,"title":"Basic Matrix and Vector Operations","text":"","path":["Solutions"],"tags":[]},{"location":"solutions/#1-vector-creation-and-access","level":3,"title":"1. Vector Creation and Access","text":"<ul> <li>Source code: ex01.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#2-matrix-initialization","level":3,"title":"2. Matrix Initialization","text":"<ul> <li>Source code: ex02.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#3-basic-math-functions","level":3,"title":"3. Basic Math Functions","text":"<ul> <li>Source code: ex03.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#4-coefficient-wise-operations","level":3,"title":"4. Coefficient-wise Operations","text":"<ul> <li>Source code: ex04.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#5-matrix-operations","level":3,"title":"5. Matrix Operations","text":"<ul> <li>Source code: ex05.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#6-vector-matrix-operations","level":3,"title":"6. Vector-Matrix Operations","text":"<ul> <li>Source code: ex06.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#7-special-matrix-operations","level":3,"title":"7. Special Matrix Operations","text":"<ul> <li>Source code: ex07.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#advanced-matrix-operations","level":2,"title":"Advanced Matrix Operations","text":"","path":["Solutions"],"tags":[]},{"location":"solutions/#8-block-operations","level":3,"title":"8. Block Operations","text":"<ul> <li>Source code: ex08.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#9-row-and-column-operations","level":3,"title":"9. Row and Column Operations","text":"<ul> <li>Source code: ex09.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#10-resizing-and-reshaping","level":3,"title":"10. Resizing and Reshaping","text":"<ul> <li>Source code: ex10.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#11-concatenation","level":3,"title":"11. Concatenation","text":"<ul> <li>Source code: ex11.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#12-advanced-slicing","level":3,"title":"12. Advanced Slicing","text":"<ul> <li>Source code: ex12.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#13-linear-algebra-operations","level":3,"title":"13. Linear Algebra Operations","text":"<ul> <li>Source code: ex13.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#14-eigenvalues-and-eigenvectors","level":3,"title":"14. Eigenvalues and Eigenvectors","text":"<ul> <li>Source code: ex14.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]},{"location":"solutions/#practical-applications","level":2,"title":"Practical Applications","text":"","path":["Solutions"],"tags":[]},{"location":"solutions/#15-image-processing-basics","level":3,"title":"15. Image Processing Basics","text":"<ul> <li>Source code: ex15.cpp</li> <li>Compiler Explorer: Open solution</li> </ul>","path":["Solutions"],"tags":[]}]}